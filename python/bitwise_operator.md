# 비트연산자
## 1. 2진법 (binary)
### 1. 기초
- 컴퓨터는 0과 1만 사용하는 2진법을 기반으로 동작한다.
### 2. 십진수 ↔ 2진수 변환 방법
#### (1) 십진수 → 2진수 변환
십진수를 2로 계속 나누면서 나머지를 보면 된다.
- 예: 13을 2진수로 변환
```
13 ÷ 2 = 6  ... 나머지 1
 6 ÷ 2 = 3  ... 나머지 0
 3 ÷ 2 = 1  ... 나머지 1
 1 ÷ 2 = 0  ... 나머지 1
```
아래에서 위로 읽으면 1101이므로 13(10진수) = 1101(2진수)
#### (2) 2진수 → 십진수 변환
2진수를 각 자리의 2의 제곱을 곱해서 더한다.
- 예: 1101(2진수)를 10진수로 변환
```
1 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰  
= 8 + 4 + 0 + 1  
= 13 (10진수)
```
### 3. 2진법을 알아야 하는 이유
비트 연산은 숫자를 2진수로 변환한 후 각 자리(비트)에서 연산을 수행하는 방식인데 이게 근소하게 빠르게 계산이 완료된다.
- 예: 비트연산 `&`(AND) 연산은 두 숫자를 2진수로 변환한 뒤 각 자릿수를 비교하여 둘 다 1이면 1, 아니면 0을 반환한다.
#### 0. 0b
파이썬에서 숫자를 2진수로 표현할 때는 앞에 0b(소문자) 또는 0B(대문자)를 붙인다.
```
num = 0b1101  # 2진수 1101 = 10진수 13
print(num)  # 출력: 13
```
#### 1. & (and)
두 비트가 모두 1일 때만 1을 반환
```
a = 0b1101  # 13 (2진수: 1101)
b = 0b1011  # 11 (2진수: 1011)
result = a & b  # 1001 (2진수) -> 9 (10진수)
print(bin(result))  # 출력: 0b1001
```
#### 2. | (or)
하나라도 1이면 1을 반환
```
a = 0b1101  # 13
b = 0b1011  # 11
result = a | b  # 1111 (2진수) -> 15 (10진수)
print(bin(result))  # 출력: 0b1111
```
#### 3. ^ (xor)
두 비트가 다르면 1을 반환하고, 같으면 0을 반환
```
a = 0b1101  # 13
b = 0b1011  # 11
result = a ^ b  # 0110 (2진수) -> 6 (10진수)
print(bin(result))  # 출력: 0b110
```
#### 4. ~ (not)
비트를 반전(0 ↔ 1)한다. 파이썬에서는 2의 보수 표현을 사용하기 때문에 `~x = -x - 1`이다
```
a = 0b1101  # 13
result = ~a  # -14 (10진수) (비트 반전 후 보수 적용)
print(bin(result))  # 출력: -0b1110
```
#### 5. << (left shift)
비트를 왼쪽으로 이동시키며, 이동한 만큼 2의 배수 곱셈 효과를 가진다.(세균증식 두배->두배->두배->...)
- x << n = x * 2^n
```
a = 0b0001  # 1
result = a << 2  # 0100 (2진수) -> 4 (10진수)
print(bin(result))  # 출력: 0b100
```
#### 6. >> (right shift)
비트를 오른쪽으로 이동시키며, 이동한 만큼 2의 배수 나눗셈 효과를 가진다.
- x >> n = x // 2^n
```
a = 0b1000  # 8
result = a >> 2  # 0010 (2진수) -> 2 (10진수)
print(bin(result))  # 출력: 0b10
```
### what can it do?
솔직히 이걸로 뭘 할 수 있을지 아직은 모르겠다.